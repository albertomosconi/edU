.
.
.
.
38. Structured Programming supports the law of the excluded middle.
.
.
.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21. Optimization hinders evolution.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
.
.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
.
.
.
115. Most people find the concept of programming obvious, but the doing impossible.
102. One can't proceed from the informal to the formal by formal means.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
1. One man's constant is another man's variable.
41. Some programming languages manage to absorb change, but withstand progress.
.
.
.
.
.
.
.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
7. It is easier to write an incorrect program than understand a correct one.
.
.
.
.
.
.
.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
.
.
.
21. Optimization hinders evolution.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
.
.
.
110. Editing is a rewording activity.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
.
.
.
.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
27. Once you understand how to write a program get someone else to write it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
.
.
.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
27. Once you understand how to write a program get someone else to write it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
17. If a listener nods his head when you're explaining your program, wake him up.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
61. In programming, as in everything else, to be in error is to be reborn.
.
.
.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
.
.
110. Editing is a rewording activity.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
.
.
.
.
.
.
.
.
.
.
.
40. There are two ways to write error-free programs; only the third one works.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
98. In computing, the mean time to failure keeps getting shorter.
.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
105. You can't communicate complexity, only an awareness of it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
.
.
.
.
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
.
.
.
114. Within a computer natural language is unnatural.
.
.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
.
.
.
.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
.
.
.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
.
.
.
.
.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
.
.
.
.
.
.
105. You can't communicate complexity, only an awareness of it.
.
.
.
.
.
.
.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
.
.
.
.
.
.
.
.
112. Computer Science is embarrassed by the computer.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
59. In English every word can be verbed. Would that it were so in our programming languages.
.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
.
.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
63. When we write programs that "learn", it turns out that we do and they don't.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
.
.
.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
.
.
.
.
.
57. It is easier to change the specification to fit the program than vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
.
.
.
.
.
.
.
.
.
.
.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
15. Everything should be built top-down, except the first time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
17. If a listener nods his head when you're explaining your program, wake him up.
.
.
.
.
.
.
17. If a listener nods his head when you're explaining your program, wake him up.
.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
112. Computer Science is embarrassed by the computer.
62. In computing, invariants are ephemeral.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
21. Optimization hinders evolution.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
.
.
.
.
.
.
96. Computers don't introduce order anywhere as much as they expose opportunities.
.
.
.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
96. Computers don't introduce order anywhere as much as they expose opportunities.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
72. An adequate bootstrap is a contradiction in terms.
96. Computers don't introduce order anywhere as much as they expose opportunities.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
.
.
.
.
.
.
.
.
.
.
.
.
.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
27. Once you understand how to write a program get someone else to write it.
.
.
.
.
.
.
.
.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
78. If your computer speaks English, it was probably made in Japan.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
.
.
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
103. Purely applicative languages are poorly applicable.
115. Most people find the concept of programming obvious, but the doing impossible.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
3. Syntactic sugar causes cancer of the semicolon.
40. There are two ways to write error-free programs; only the third one works.
55. A LISP programmer knows the value of everything, but the cost of nothing.
.
.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
3. Syntactic sugar causes cancer of the semicolon.
40. There are two ways to write error-free programs; only the third one works.
55. A LISP programmer knows the value of everything, but the cost of nothing.
.
.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
72. An adequate bootstrap is a contradiction in terms.
.
.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
57. It is easier to change the specification to fit the program than vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41. Some programming languages manage to absorb change, but withstand progress.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
.
.
.
.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
.
.
.
.
.
114. Within a computer natural language is unnatural.
108. Whenever two programmers meet to criticize their programs, both are silent.
.
.
.
.
.
.
.
.
.
.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15. Everything should be built top-down, except the first time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
.
.
.
.
.
.
.
.

111. Why did the Roman Empire collapse? What is Latin for office automation?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
