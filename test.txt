541u
837,966p
565u
233,667d
66u
172,195d
746r
974,1001p
581r
191u
355,432d
692u
1018u
976r
680r
1006u
468r
237,791p
206,396d
1,988c
38. Structured Programming supports the law of the excluded middle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
17. If a listener nods his head when you're explaining your program, wake him up.
57. It is easier to change the specification to fit the program than vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
63. When we write programs that "learn", it turns out that we do and they don't.
57. It is easier to change the specification to fit the program than vice versa.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
66. Making something variable is easy. Controlling duration of constancy is the trick.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
3. Syntactic sugar causes cancer of the semicolon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
119. Programming is an unnatural act.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
55. A LISP programmer knows the value of everything, but the cost of nothing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
103. Purely applicative languages are poorly applicable.
76. It is the user who should parameterize procedures, not their creators.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
95. Don't have good ideas if you aren't willing to be responsible for them.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
31. Simplicity does not precede complexity, but follows it.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
47. As Will Rogers would have said, "There is no such thing as a free variable."
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
31. Simplicity does not precede complexity, but follows it.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
4. Every program is a part of some other program and rarely fits.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
1. One man's constant is another man's variable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
78. If your computer speaks English, it was probably made in Japan.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
110. Editing is a rewording activity.
43. In software systems, it is often the early bird that makes the worm.
43. In software systems, it is often the early bird that makes the worm.
63. When we write programs that "learn", it turns out that we do and they don't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
108. Whenever two programmers meet to criticize their programs, both are silent.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
96. Computers don't introduce order anywhere as much as they expose opportunities.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
63. When we write programs that "learn", it turns out that we do and they don't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
115. Most people find the concept of programming obvious, but the doing impossible.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
111. Why did the Roman Empire collapse? What is Latin for office automation?
41. Some programming languages manage to absorb change, but withstand progress.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
115. Most people find the concept of programming obvious, but the doing impossible.
60. In seeking the unattainable, simplicity only gets in the way.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
21. Optimization hinders evolution.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
110. Editing is a rewording activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
98. In computing, the mean time to failure keeps getting shorter.
22. A good system can't have a weak command language.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
15. Everything should be built top-down, except the first time.
17. If a listener nods his head when you're explaining your program, wake him up.
78. If your computer speaks English, it was probably made in Japan.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
31. Simplicity does not precede complexity, but follows it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
112. Computer Science is embarrassed by the computer.
55. A LISP programmer knows the value of everything, but the cost of nothing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
62. In computing, invariants are ephemeral.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
95. Don't have good ideas if you aren't willing to be responsible for them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
104. The proof of a system's value is its existence.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
38. Structured Programming supports the law of the excluded middle.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
3. Syntactic sugar causes cancer of the semicolon.
21. Optimization hinders evolution.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
43. In software systems, it is often the early bird that makes the worm.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
12. Recursion is the root of computation since it trades description for time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
108. Whenever two programmers meet to criticize their programs, both are silent.
112. Computer Science is embarrassed by the computer.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
31. Simplicity does not precede complexity, but follows it.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
96. Computers don't introduce order anywhere as much as they expose opportunities.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
100. We will never run out of things to program as long as there is a single program around.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
8. A programming language is low level when its programs require attention to the irrelevant.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
108. Whenever two programmers meet to criticize their programs, both are silent.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
104. The proof of a system's value is its existence.
11. If you have a procedure with ten parameters, you probably missed some.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
72. An adequate bootstrap is a contradiction in terms.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
115. Most people find the concept of programming obvious, but the doing impossible.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
112. Computer Science is embarrassed by the computer.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
3. Syntactic sugar causes cancer of the semicolon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
1. One man's constant is another man's variable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
76. It is the user who should parameterize procedures, not their creators.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
3. Syntactic sugar causes cancer of the semicolon.
114. Within a computer natural language is unnatural.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
102. One can't proceed from the informal to the formal by formal means.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
115. Most people find the concept of programming obvious, but the doing impossible.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
110. Editing is a rewording activity.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
57. It is easier to change the specification to fit the program than vice versa.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
112. Computer Science is embarrassed by the computer.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
62. In computing, invariants are ephemeral.
3. Syntactic sugar causes cancer of the semicolon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
79. A year spent in artificial intelligence is enough to make one believe in God.
15. Everything should be built top-down, except the first time.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
63. When we write programs that "learn", it turns out that we do and they don't.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
102. One can't proceed from the informal to the formal by formal means.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
60. In seeking the unattainable, simplicity only gets in the way.
59. In English every word can be verbed. Would that it were so in our programming languages.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
115. Most people find the concept of programming obvious, but the doing impossible.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
38. Structured Programming supports the law of the excluded middle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
119. Programming is an unnatural act.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
57. It is easier to change the specification to fit the program than vice versa.
21. Optimization hinders evolution.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
111. Why did the Roman Empire collapse? What is Latin for office automation?
21. Optimization hinders evolution.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
79. A year spent in artificial intelligence is enough to make one believe in God.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
111. Why did the Roman Empire collapse? What is Latin for office automation?
90. Computation has made the tree flower.
21. Optimization hinders evolution.
31. Simplicity does not precede complexity, but follows it.
79. A year spent in artificial intelligence is enough to make one believe in God.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
12. Recursion is the root of computation since it trades description for time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
105. You can't communicate complexity, only an awareness of it.
41. Some programming languages manage to absorb change, but withstand progress.
12. Recursion is the root of computation since it trades description for time.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
114. Within a computer natural language is unnatural.
112. Computer Science is embarrassed by the computer.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
95. Don't have good ideas if you aren't willing to be responsible for them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
96. Computers don't introduce order anywhere as much as they expose opportunities.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
104. The proof of a system's value is its existence.
95. Don't have good ideas if you aren't willing to be responsible for them.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
104. The proof of a system's value is its existence.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
98. In computing, the mean time to failure keeps getting shorter.
4. Every program is a part of some other program and rarely fits.
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
72. An adequate bootstrap is a contradiction in terms.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
66. Making something variable is easy. Controlling duration of constancy is the trick.
8. A programming language is low level when its programs require attention to the irrelevant.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
7. It is easier to write an incorrect program than understand a correct one.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
3. Syntactic sugar causes cancer of the semicolon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
79. A year spent in artificial intelligence is enough to make one believe in God.
108. Whenever two programmers meet to criticize their programs, both are silent.
63. When we write programs that "learn", it turns out that we do and they don't.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
57. It is easier to change the specification to fit the program than vice versa.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
40. There are two ways to write error-free programs; only the third one works.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
47. As Will Rogers would have said, "There is no such thing as a free variable."
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
12. Recursion is the root of computation since it trades description for time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
23. To understand a program you must become both the machine and the program.
38. Structured Programming supports the law of the excluded middle.
78. If your computer speaks English, it was probably made in Japan.
60. In seeking the unattainable, simplicity only gets in the way.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
66. Making something variable is easy. Controlling duration of constancy is the trick.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
60. In seeking the unattainable, simplicity only gets in the way.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
95. Don't have good ideas if you aren't willing to be responsible for them.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
103. Purely applicative languages are poorly applicable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
102. One can't proceed from the informal to the formal by formal means.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
76. It is the user who should parameterize procedures, not their creators.
31. Simplicity does not precede complexity, but follows it.
7. It is easier to write an incorrect program than understand a correct one.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
105. You can't communicate complexity, only an awareness of it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
1. One man's constant is another man's variable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
21. Optimization hinders evolution.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
31. Simplicity does not precede complexity, but follows it.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
100. We will never run out of things to program as long as there is a single program around.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
14. In the long run every program becomes rococo - then rubble.
62. In computing, invariants are ephemeral.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
105. You can't communicate complexity, only an awareness of it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
114. Within a computer natural language is unnatural.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
63. When we write programs that "learn", it turns out that we do and they don't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
55. A LISP programmer knows the value of everything, but the cost of nothing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
46. Like punning, programming is a play on words.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
21. Optimization hinders evolution.
4. Every program is a part of some other program and rarely fits.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
8. A programming language is low level when its programs require attention to the irrelevant.
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
31. Simplicity does not precede complexity, but follows it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
57. It is easier to change the specification to fit the program than vice versa.
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
104. The proof of a system's value is its existence.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
76. It is the user who should parameterize procedures, not their creators.
14. In the long run every program becomes rococo - then rubble.
61. In programming, as in everything else, to be in error is to be reborn.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
47. As Will Rogers would have said, "There is no such thing as a free variable."
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
1. One man's constant is another man's variable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
3. Syntactic sugar causes cancer of the semicolon.
79. A year spent in artificial intelligence is enough to make one believe in God.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
4. Every program is a part of some other program and rarely fits.
41. Some programming languages manage to absorb change, but withstand progress.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
79. A year spent in artificial intelligence is enough to make one believe in God.
12. Recursion is the root of computation since it trades description for time.
72. An adequate bootstrap is a contradiction in terms.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
4. Every program is a part of some other program and rarely fits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
115. Most people find the concept of programming obvious, but the doing impossible.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
38. Structured Programming supports the law of the excluded middle.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
102. One can't proceed from the informal to the formal by formal means.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
21. Optimization hinders evolution.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
38. Structured Programming supports the law of the excluded middle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
90. Computation has made the tree flower.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
1. One man's constant is another man's variable.
12. Recursion is the root of computation since it trades description for time.
100. We will never run out of things to program as long as there is a single program around.
111. Why did the Roman Empire collapse? What is Latin for office automation?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
95. Don't have good ideas if you aren't willing to be responsible for them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
27. Once you understand how to write a program get someone else to write it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
119. Programming is an unnatural act.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
108. Whenever two programmers meet to criticize their programs, both are silent.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
.
729r
509,750d
380,1015p
155,814d
138,233d
33,294c
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
43. In software systems, it is often the early bird that makes the worm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
11. If you have a procedure with ten parameters, you probably missed some.
31. Simplicity does not precede complexity, but follows it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
3. Syntactic sugar causes cancer of the semicolon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
90. Computation has made the tree flower.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
63. When we write programs that "learn", it turns out that we do and they don't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
41. Some programming languages manage to absorb change, but withstand progress.
76. It is the user who should parameterize procedures, not their creators.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
78. If your computer speaks English, it was probably made in Japan.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
96. Computers don't introduce order anywhere as much as they expose opportunities.
72. An adequate bootstrap is a contradiction in terms.
104. The proof of a system's value is its existence.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
41. Some programming languages manage to absorb change, but withstand progress.
115. Most people find the concept of programming obvious, but the doing impossible.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
90. Computation has made the tree flower.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
66. Making something variable is easy. Controlling duration of constancy is the trick.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
8. A programming language is low level when its programs require attention to the irrelevant.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
76. It is the user who should parameterize procedures, not their creators.
46. Like punning, programming is a play on words.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
43. In software systems, it is often the early bird that makes the worm.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
62. In computing, invariants are ephemeral.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
59. In English every word can be verbed. Would that it were so in our programming languages.
38. Structured Programming supports the law of the excluded middle.
12. Recursion is the root of computation since it trades description for time.
100. We will never run out of things to program as long as there is a single program around.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
62. In computing, invariants are ephemeral.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
11. If you have a procedure with ten parameters, you probably missed some.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
111. Why did the Roman Empire collapse? What is Latin for office automation?
95. Don't have good ideas if you aren't willing to be responsible for them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
14. In the long run every program becomes rococo - then rubble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
17. If a listener nods his head when you're explaining your program, wake him up.
79. A year spent in artificial intelligence is enough to make one believe in God.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
111. Why did the Roman Empire collapse? What is Latin for office automation?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
11. If you have a procedure with ten parameters, you probably missed some.
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
15. Everything should be built top-down, except the first time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
62. In computing, invariants are ephemeral.
43. In software systems, it is often the early bird that makes the worm.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
40. There are two ways to write error-free programs; only the third one works.
1. One man's constant is another man's variable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
40. There are two ways to write error-free programs; only the third one works.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
60. In seeking the unattainable, simplicity only gets in the way.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
104. The proof of a system's value is its existence.
95. Don't have good ideas if you aren't willing to be responsible for them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
110. Editing is a rewording activity.
22. A good system can't have a weak command language.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
4. Every program is a part of some other program and rarely fits.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
1. One man's constant is another man's variable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
.
577,993p
136,435p
902,976p
249,436d
194,211d
608u
677u
40u
995,1005d
6r
184,307d
101,577p
910,962d
137,173d
999u
24r
74,838p
537r
1,223c
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
98. In computing, the mean time to failure keeps getting shorter.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
46. Like punning, programming is a play on words.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
98. In computing, the mean time to failure keeps getting shorter.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
104. The proof of a system's value is its existence.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
11. If you have a procedure with ten parameters, you probably missed some.
12. Recursion is the root of computation since it trades description for time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
95. Don't have good ideas if you aren't willing to be responsible for them.
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
61. In programming, as in everything else, to be in error is to be reborn.
1. One man's constant is another man's variable.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
119. Programming is an unnatural act.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
59. In English every word can be verbed. Would that it were so in our programming languages.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
96. Computers don't introduce order anywhere as much as they expose opportunities.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
14. In the long run every program becomes rococo - then rubble.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
46. Like punning, programming is a play on words.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
61. In programming, as in everything else, to be in error is to be reborn.
61. In programming, as in everything else, to be in error is to be reborn.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
40. There are two ways to write error-free programs; only the third one works.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
104. The proof of a system's value is its existence.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
105. You can't communicate complexity, only an awareness of it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
95. Don't have good ideas if you aren't willing to be responsible for them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
115. Most people find the concept of programming obvious, but the doing impossible.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
79. A year spent in artificial intelligence is enough to make one believe in God.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
115. Most people find the concept of programming obvious, but the doing impossible.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
21. Optimization hinders evolution.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
38. Structured Programming supports the law of the excluded middle.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
17. If a listener nods his head when you're explaining your program, wake him up.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
40. There are two ways to write error-free programs; only the third one works.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
60. In seeking the unattainable, simplicity only gets in the way.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
8. A programming language is low level when its programs require attention to the irrelevant.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
102. One can't proceed from the informal to the formal by formal means.
114. Within a computer natural language is unnatural.
78. If your computer speaks English, it was probably made in Japan.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
110. Editing is a rewording activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
72. An adequate bootstrap is a contradiction in terms.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
47. As Will Rogers would have said, "There is no such thing as a free variable."
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
100. We will never run out of things to program as long as there is a single program around.
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
79. A year spent in artificial intelligence is enough to make one believe in God.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
21. Optimization hinders evolution.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
46. Like punning, programming is a play on words.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
60. In seeking the unattainable, simplicity only gets in the way.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
1. One man's constant is another man's variable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
18. A program without a loop and a structured variable isn't worth writing.
61. In programming, as in everything else, to be in error is to be reborn.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
4. Every program is a part of some other program and rarely fits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
111. Why did the Roman Empire collapse? What is Latin for office automation?
.
608r
21,850c
41. Some programming languages manage to absorb change, but withstand progress.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
46. Like punning, programming is a play on words.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
103. Purely applicative languages are poorly applicable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
22. A good system can't have a weak command language.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
38. Structured Programming supports the law of the excluded middle.
46. Like punning, programming is a play on words.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
41. Some programming languages manage to absorb change, but withstand progress.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
8. A programming language is low level when its programs require attention to the irrelevant.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
8. A programming language is low level when its programs require attention to the irrelevant.
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
102. One can't proceed from the informal to the formal by formal means.
62. In computing, invariants are ephemeral.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
102. One can't proceed from the informal to the formal by formal means.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
55. A LISP programmer knows the value of everything, but the cost of nothing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
7. It is easier to write an incorrect program than understand a correct one.
102. One can't proceed from the informal to the formal by formal means.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
119. Programming is an unnatural act.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
18. A program without a loop and a structured variable isn't worth writing.
17. If a listener nods his head when you're explaining your program, wake him up.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
1. One man's constant is another man's variable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
95. Don't have good ideas if you aren't willing to be responsible for them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
98. In computing, the mean time to failure keeps getting shorter.
119. Programming is an unnatural act.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
8. A programming language is low level when its programs require attention to the irrelevant.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
104. The proof of a system's value is its existence.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
27. Once you understand how to write a program get someone else to write it.
102. One can't proceed from the informal to the formal by formal means.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
98. In computing, the mean time to failure keeps getting shorter.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
98. In computing, the mean time to failure keeps getting shorter.
103. Purely applicative languages are poorly applicable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
14. In the long run every program becomes rococo - then rubble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
14. In the long run every program becomes rococo - then rubble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
1. One man's constant is another man's variable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
76. It is the user who should parameterize procedures, not their creators.
110. Editing is a rewording activity.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
46. Like punning, programming is a play on words.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
22. A good system can't have a weak command language.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
57. It is easier to change the specification to fit the program than vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
60. In seeking the unattainable, simplicity only gets in the way.
7. It is easier to write an incorrect program than understand a correct one.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
96. Computers don't introduce order anywhere as much as they expose opportunities.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
111. Why did the Roman Empire collapse? What is Latin for office automation?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
72. An adequate bootstrap is a contradiction in terms.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
78. If your computer speaks English, it was probably made in Japan.
43. In software systems, it is often the early bird that makes the worm.
11. If you have a procedure with ten parameters, you probably missed some.
41. Some programming languages manage to absorb change, but withstand progress.
14. In the long run every program becomes rococo - then rubble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
95. Don't have good ideas if you aren't willing to be responsible for them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
60. In seeking the unattainable, simplicity only gets in the way.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
103. Purely applicative languages are poorly applicable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
60. In seeking the unattainable, simplicity only gets in the way.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
40. There are two ways to write error-free programs; only the third one works.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
66. Making something variable is easy. Controlling duration of constancy is the trick.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
119. Programming is an unnatural act.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
18. A program without a loop and a structured variable isn't worth writing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
63. When we write programs that "learn", it turns out that we do and they don't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
119. Programming is an unnatural act.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
17. If a listener nods his head when you're explaining your program, wake him up.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
3. Syntactic sugar causes cancer of the semicolon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
100. We will never run out of things to program as long as there is a single program around.
90. Computation has made the tree flower.
61. In programming, as in everything else, to be in error is to be reborn.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
112. Computer Science is embarrassed by the computer.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
14. In the long run every program becomes rococo - then rubble.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
61. In programming, as in everything else, to be in error is to be reborn.
108. Whenever two programmers meet to criticize their programs, both are silent.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
108. Whenever two programmers meet to criticize their programs, both are silent.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
110. Editing is a rewording activity.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
47. As Will Rogers would have said, "There is no such thing as a free variable."
76. It is the user who should parameterize procedures, not their creators.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
90. Computation has made the tree flower.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
38. Structured Programming supports the law of the excluded middle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
108. Whenever two programmers meet to criticize their programs, both are silent.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
22. A good system can't have a weak command language.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
59. In English every word can be verbed. Would that it were so in our programming languages.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
27. Once you understand how to write a program get someone else to write it.
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
105. You can't communicate complexity, only an awareness of it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
12. Recursion is the root of computation since it trades description for time.
15. Everything should be built top-down, except the first time.
14. In the long run every program becomes rococo - then rubble.
11. If you have a procedure with ten parameters, you probably missed some.
59. In English every word can be verbed. Would that it were so in our programming languages.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
23. To understand a program you must become both the machine and the program.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
102. One can't proceed from the informal to the formal by formal means.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
11. If you have a procedure with ten parameters, you probably missed some.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
76. It is the user who should parameterize procedures, not their creators.
100. We will never run out of things to program as long as there is a single program around.
61. In programming, as in everything else, to be in error is to be reborn.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
15. Everything should be built top-down, except the first time.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
57. It is easier to change the specification to fit the program than vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
63. When we write programs that "learn", it turns out that we do and they don't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
43. In software systems, it is often the early bird that makes the worm.
31. Simplicity does not precede complexity, but follows it.
11. If you have a procedure with ten parameters, you probably missed some.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
55. A LISP programmer knows the value of everything, but the cost of nothing.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
4. Every program is a part of some other program and rarely fits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
90. Computation has made the tree flower.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
23. To understand a program you must become both the machine and the program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
15. Everything should be built top-down, except the first time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
95. Don't have good ideas if you aren't willing to be responsible for them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
17. If a listener nods his head when you're explaining your program, wake him up.
76. It is the user who should parameterize procedures, not their creators.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
103. Purely applicative languages are poorly applicable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
47. As Will Rogers would have said, "There is no such thing as a free variable."
107. The debate rages on: is PL/I Bachtrian or Dromedary?
78. If your computer speaks English, it was probably made in Japan.
60. In seeking the unattainable, simplicity only gets in the way.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
60. In seeking the unattainable, simplicity only gets in the way.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
115. Most people find the concept of programming obvious, but the doing impossible.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
46. Like punning, programming is a play on words.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
105. You can't communicate complexity, only an awareness of it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
78. If your computer speaks English, it was probably made in Japan.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
96. Computers don't introduce order anywhere as much as they expose opportunities.
90. Computation has made the tree flower.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
1. One man's constant is another man's variable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
14. In the long run every program becomes rococo - then rubble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
38. Structured Programming supports the law of the excluded middle.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
14. In the long run every program becomes rococo - then rubble.
115. Most people find the concept of programming obvious, but the doing impossible.
119. Programming is an unnatural act.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
78. If your computer speaks English, it was probably made in Japan.
57. It is easier to change the specification to fit the program than vice versa.
100. We will never run out of things to program as long as there is a single program around.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
23. To understand a program you must become both the machine and the program.
72. An adequate bootstrap is a contradiction in terms.
15. Everything should be built top-down, except the first time.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
18. A program without a loop and a structured variable isn't worth writing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
55. A LISP programmer knows the value of everything, but the cost of nothing.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
1. One man's constant is another man's variable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
103. Purely applicative languages are poorly applicable.
40. There are two ways to write error-free programs; only the third one works.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
27. Once you understand how to write a program get someone else to write it.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
98. In computing, the mean time to failure keeps getting shorter.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
61. In programming, as in everything else, to be in error is to be reborn.
27. Once you understand how to write a program get someone else to write it.
79. A year spent in artificial intelligence is enough to make one believe in God.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
38. Structured Programming supports the law of the excluded middle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
72. An adequate bootstrap is a contradiction in terms.
55. A LISP programmer knows the value of everything, but the cost of nothing.
108. Whenever two programmers meet to criticize their programs, both are silent.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
98. In computing, the mean time to failure keeps getting shorter.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
57. It is easier to change the specification to fit the program than vice versa.
100. We will never run out of things to program as long as there is a single program around.
38. Structured Programming supports the law of the excluded middle.
12. Recursion is the root of computation since it trades description for time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
66. Making something variable is easy. Controlling duration of constancy is the trick.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
102. One can't proceed from the informal to the formal by formal means.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
102. One can't proceed from the informal to the formal by formal means.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
41. Some programming languages manage to absorb change, but withstand progress.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
7. It is easier to write an incorrect program than understand a correct one.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
18. A program without a loop and a structured variable isn't worth writing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
46. Like punning, programming is a play on words.
100. We will never run out of things to program as long as there is a single program around.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
76. It is the user who should parameterize procedures, not their creators.
100. We will never run out of things to program as long as there is a single program around.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
61. In programming, as in everything else, to be in error is to be reborn.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
95. Don't have good ideas if you aren't willing to be responsible for them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
111. Why did the Roman Empire collapse? What is Latin for office automation?
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
46. Like punning, programming is a play on words.
57. It is easier to change the specification to fit the program than vice versa.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
43. In software systems, it is often the early bird that makes the worm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
108. Whenever two programmers meet to criticize their programs, both are silent.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
108. Whenever two programmers meet to criticize their programs, both are silent.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
102. One can't proceed from the informal to the formal by formal means.
47. As Will Rogers would have said, "There is no such thing as a free variable."
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
78. If your computer speaks English, it was probably made in Japan.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
114. Within a computer natural language is unnatural.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
22. A good system can't have a weak command language.
.
220u
313,475p
748u
463r
453,981c
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
17. If a listener nods his head when you're explaining your program, wake him up.
11. If you have a procedure with ten parameters, you probably missed some.
61. In programming, as in everything else, to be in error is to be reborn.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
108. Whenever two programmers meet to criticize their programs, both are silent.
66. Making something variable is easy. Controlling duration of constancy is the trick.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
1. One man's constant is another man's variable.
15. Everything should be built top-down, except the first time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
115. Most people find the concept of programming obvious, but the doing impossible.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
57. It is easier to change the specification to fit the program than vice versa.
3. Syntactic sugar causes cancer of the semicolon.
115. Most people find the concept of programming obvious, but the doing impossible.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
22. A good system can't have a weak command language.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
1. One man's constant is another man's variable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
4. Every program is a part of some other program and rarely fits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
79. A year spent in artificial intelligence is enough to make one believe in God.
78. If your computer speaks English, it was probably made in Japan.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
60. In seeking the unattainable, simplicity only gets in the way.
41. Some programming languages manage to absorb change, but withstand progress.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
108. Whenever two programmers meet to criticize their programs, both are silent.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
60. In seeking the unattainable, simplicity only gets in the way.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
62. In computing, invariants are ephemeral.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
95. Don't have good ideas if you aren't willing to be responsible for them.
72. An adequate bootstrap is a contradiction in terms.
105. You can't communicate complexity, only an awareness of it.
11. If you have a procedure with ten parameters, you probably missed some.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
43. In software systems, it is often the early bird that makes the worm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
8. A programming language is low level when its programs require attention to the irrelevant.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
119. Programming is an unnatural act.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
78. If your computer speaks English, it was probably made in Japan.
110. Editing is a rewording activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
55. A LISP programmer knows the value of everything, but the cost of nothing.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
15. Everything should be built top-down, except the first time.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
41. Some programming languages manage to absorb change, but withstand progress.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
27. Once you understand how to write a program get someone else to write it.
40. There are two ways to write error-free programs; only the third one works.
41. Some programming languages manage to absorb change, but withstand progress.
31. Simplicity does not precede complexity, but follows it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
102. One can't proceed from the informal to the formal by formal means.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
23. To understand a program you must become both the machine and the program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
103. Purely applicative languages are poorly applicable.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
21. Optimization hinders evolution.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
43. In software systems, it is often the early bird that makes the worm.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
98. In computing, the mean time to failure keeps getting shorter.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
108. Whenever two programmers meet to criticize their programs, both are silent.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
7. It is easier to write an incorrect program than understand a correct one.
14. In the long run every program becomes rococo - then rubble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
46. Like punning, programming is a play on words.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
11. If you have a procedure with ten parameters, you probably missed some.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
3. Syntactic sugar causes cancer of the semicolon.
110. Editing is a rewording activity.
7. It is easier to write an incorrect program than understand a correct one.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
8. A programming language is low level when its programs require attention to the irrelevant.
21. Optimization hinders evolution.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
40. There are two ways to write error-free programs; only the third one works.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
61. In programming, as in everything else, to be in error is to be reborn.
21. Optimization hinders evolution.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
14. In the long run every program becomes rococo - then rubble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
3. Syntactic sugar causes cancer of the semicolon.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
23. To understand a program you must become both the machine and the program.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
7. It is easier to write an incorrect program than understand a correct one.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
60. In seeking the unattainable, simplicity only gets in the way.
18. A program without a loop and a structured variable isn't worth writing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
15. Everything should be built top-down, except the first time.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
72. An adequate bootstrap is a contradiction in terms.
114. Within a computer natural language is unnatural.
110. Editing is a rewording activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
3. Syntactic sugar causes cancer of the semicolon.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
62. In computing, invariants are ephemeral.
102. One can't proceed from the informal to the formal by formal means.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
108. Whenever two programmers meet to criticize their programs, both are silent.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
18. A program without a loop and a structured variable isn't worth writing.
14. In the long run every program becomes rococo - then rubble.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
90. Computation has made the tree flower.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
43. In software systems, it is often the early bird that makes the worm.
59. In English every word can be verbed. Would that it were so in our programming languages.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
3. Syntactic sugar causes cancer of the semicolon.
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
110. Editing is a rewording activity.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
95. Don't have good ideas if you aren't willing to be responsible for them.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
114. Within a computer natural language is unnatural.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
62. In computing, invariants are ephemeral.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
63. When we write programs that "learn", it turns out that we do and they don't.
21. Optimization hinders evolution.
60. In seeking the unattainable, simplicity only gets in the way.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
63. When we write programs that "learn", it turns out that we do and they don't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
15. Everything should be built top-down, except the first time.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
110. Editing is a rewording activity.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
21. Optimization hinders evolution.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
14. In the long run every program becomes rococo - then rubble.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
57. It is easier to change the specification to fit the program than vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
72. An adequate bootstrap is a contradiction in terms.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
114. Within a computer natural language is unnatural.
21. Optimization hinders evolution.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
17. If a listener nods his head when you're explaining your program, wake him up.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
1. One man's constant is another man's variable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
114. Within a computer natural language is unnatural.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
60. In seeking the unattainable, simplicity only gets in the way.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
98. In computing, the mean time to failure keeps getting shorter.
79. A year spent in artificial intelligence is enough to make one believe in God.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
78. If your computer speaks English, it was probably made in Japan.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
76. It is the user who should parameterize procedures, not their creators.
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
22. A good system can't have a weak command language.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
38. Structured Programming supports the law of the excluded middle.
100. We will never run out of things to program as long as there is a single program around.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
27. Once you understand how to write a program get someone else to write it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
98. In computing, the mean time to failure keeps getting shorter.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
96. Computers don't introduce order anywhere as much as they expose opportunities.
4. Every program is a part of some other program and rarely fits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
103. Purely applicative languages are poorly applicable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
21. Optimization hinders evolution.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
21. Optimization hinders evolution.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
66. Making something variable is easy. Controlling duration of constancy is the trick.
38. Structured Programming supports the law of the excluded middle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
46. Like punning, programming is a play on words.
90. Computation has made the tree flower.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
102. One can't proceed from the informal to the formal by formal means.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
17. If a listener nods his head when you're explaining your program, wake him up.
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
17. If a listener nods his head when you're explaining your program, wake him up.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
108. Whenever two programmers meet to criticize their programs, both are silent.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
108. Whenever two programmers meet to criticize their programs, both are silent.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
98. In computing, the mean time to failure keeps getting shorter.
100. We will never run out of things to program as long as there is a single program around.
66. Making something variable is easy. Controlling duration of constancy is the trick.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
79. A year spent in artificial intelligence is enough to make one believe in God.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
3. Syntactic sugar causes cancer of the semicolon.
22. A good system can't have a weak command language.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
103. Purely applicative languages are poorly applicable.
108. Whenever two programmers meet to criticize their programs, both are silent.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
95. Don't have good ideas if you aren't willing to be responsible for them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
104. The proof of a system's value is its existence.
115. Most people find the concept of programming obvious, but the doing impossible.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
.
215,670p
771u
617r
515,746p
720,815d
705u
492r
952,977d
819,847d
177r
977,983p
672,988p
430r
818,962c
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
100. We will never run out of things to program as long as there is a single program around.
103. Purely applicative languages are poorly applicable.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
23. To understand a program you must become both the machine and the program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
47. As Will Rogers would have said, "There is no such thing as a free variable."
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
15. Everything should be built top-down, except the first time.
3. Syntactic sugar causes cancer of the semicolon.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
12. Recursion is the root of computation since it trades description for time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
61. In programming, as in everything else, to be in error is to be reborn.
7. It is easier to write an incorrect program than understand a correct one.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
31. Simplicity does not precede complexity, but follows it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
18. A program without a loop and a structured variable isn't worth writing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
11. If you have a procedure with ten parameters, you probably missed some.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
8. A programming language is low level when its programs require attention to the irrelevant.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
103. Purely applicative languages are poorly applicable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
110. Editing is a rewording activity.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
3. Syntactic sugar causes cancer of the semicolon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
111. Why did the Roman Empire collapse? What is Latin for office automation?
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
115. Most people find the concept of programming obvious, but the doing impossible.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
55. A LISP programmer knows the value of everything, but the cost of nothing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
15. Everything should be built top-down, except the first time.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
103. Purely applicative languages are poorly applicable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
41. Some programming languages manage to absorb change, but withstand progress.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
100. We will never run out of things to program as long as there is a single program around.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
15. Everything should be built top-down, except the first time.
90. Computation has made the tree flower.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
114. Within a computer natural language is unnatural.
59. In English every word can be verbed. Would that it were so in our programming languages.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
4. Every program is a part of some other program and rarely fits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
103. Purely applicative languages are poorly applicable.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
.
704,771c
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
22. A good system can't have a weak command language.
23. To understand a program you must become both the machine and the program.
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
1. One man's constant is another man's variable.
112. Computer Science is embarrassed by the computer.
108. Whenever two programmers meet to criticize their programs, both are silent.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
78. If your computer speaks English, it was probably made in Japan.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
90. Computation has made the tree flower.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
102. One can't proceed from the informal to the formal by formal means.
4. Every program is a part of some other program and rarely fits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
7. It is easier to write an incorrect program than understand a correct one.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
104. The proof of a system's value is its existence.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
11. If you have a procedure with ten parameters, you probably missed some.
22. A good system can't have a weak command language.
41. Some programming languages manage to absorb change, but withstand progress.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
79. A year spent in artificial intelligence is enough to make one believe in God.
105. You can't communicate complexity, only an awareness of it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
119. Programming is an unnatural act.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
100. We will never run out of things to program as long as there is a single program around.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
79. A year spent in artificial intelligence is enough to make one believe in God.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
112. Computer Science is embarrassed by the computer.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
.
178u
946,1008p
983,997d
1,944c
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
47. As Will Rogers would have said, "There is no such thing as a free variable."
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
60. In seeking the unattainable, simplicity only gets in the way.
63. When we write programs that "learn", it turns out that we do and they don't.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
112. Computer Science is embarrassed by the computer.
59. In English every word can be verbed. Would that it were so in our programming languages.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
102. One can't proceed from the informal to the formal by formal means.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
31. Simplicity does not precede complexity, but follows it.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
57. It is easier to change the specification to fit the program than vice versa.
4. Every program is a part of some other program and rarely fits.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
17. If a listener nods his head when you're explaining your program, wake him up.
18. A program without a loop and a structured variable isn't worth writing.
95. Don't have good ideas if you aren't willing to be responsible for them.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
79. A year spent in artificial intelligence is enough to make one believe in God.
79. A year spent in artificial intelligence is enough to make one believe in God.
14. In the long run every program becomes rococo - then rubble.
4. Every program is a part of some other program and rarely fits.
72. An adequate bootstrap is a contradiction in terms.
57. It is easier to change the specification to fit the program than vice versa.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
1. One man's constant is another man's variable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
22. A good system can't have a weak command language.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
57. It is easier to change the specification to fit the program than vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
59. In English every word can be verbed. Would that it were so in our programming languages.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
40. There are two ways to write error-free programs; only the third one works.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
104. The proof of a system's value is its existence.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
96. Computers don't introduce order anywhere as much as they expose opportunities.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
40. There are two ways to write error-free programs; only the third one works.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
61. In programming, as in everything else, to be in error is to be reborn.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
108. Whenever two programmers meet to criticize their programs, both are silent.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
104. The proof of a system's value is its existence.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
27. Once you understand how to write a program get someone else to write it.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
11. If you have a procedure with ten parameters, you probably missed some.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
110. Editing is a rewording activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
18. A program without a loop and a structured variable isn't worth writing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
31. Simplicity does not precede complexity, but follows it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
8. A programming language is low level when its programs require attention to the irrelevant.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
22. A good system can't have a weak command language.
47. As Will Rogers would have said, "There is no such thing as a free variable."
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
119. Programming is an unnatural act.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
23. To understand a program you must become both the machine and the program.
76. It is the user who should parameterize procedures, not their creators.
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
21. Optimization hinders evolution.
43. In software systems, it is often the early bird that makes the worm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
95. Don't have good ideas if you aren't willing to be responsible for them.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
111. Why did the Roman Empire collapse? What is Latin for office automation?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
55. A LISP programmer knows the value of everything, but the cost of nothing.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
105. You can't communicate complexity, only an awareness of it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
72. An adequate bootstrap is a contradiction in terms.
112. Computer Science is embarrassed by the computer.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
104. The proof of a system's value is its existence.
21. Optimization hinders evolution.
23. To understand a program you must become both the machine and the program.
21. Optimization hinders evolution.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
22. A good system can't have a weak command language.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
72. An adequate bootstrap is a contradiction in terms.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
63. When we write programs that "learn", it turns out that we do and they don't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
18. A program without a loop and a structured variable isn't worth writing.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
21. Optimization hinders evolution.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
59. In English every word can be verbed. Would that it were so in our programming languages.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
112. Computer Science is embarrassed by the computer.
27. Once you understand how to write a program get someone else to write it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
66. Making something variable is easy. Controlling duration of constancy is the trick.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
21. Optimization hinders evolution.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
7. It is easier to write an incorrect program than understand a correct one.
79. A year spent in artificial intelligence is enough to make one believe in God.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
59. In English every word can be verbed. Would that it were so in our programming languages.
114. Within a computer natural language is unnatural.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
57. It is easier to change the specification to fit the program than vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
43. In software systems, it is often the early bird that makes the worm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
112. Computer Science is embarrassed by the computer.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
78. If your computer speaks English, it was probably made in Japan.
55. A LISP programmer knows the value of everything, but the cost of nothing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
63. When we write programs that "learn", it turns out that we do and they don't.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
38. Structured Programming supports the law of the excluded middle.
14. In the long run every program becomes rococo - then rubble.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
14. In the long run every program becomes rococo - then rubble.
76. It is the user who should parameterize procedures, not their creators.
100. We will never run out of things to program as long as there is a single program around.
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
27. Once you understand how to write a program get someone else to write it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
7. It is easier to write an incorrect program than understand a correct one.
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
112. Computer Science is embarrassed by the computer.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
108. Whenever two programmers meet to criticize their programs, both are silent.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
38. Structured Programming supports the law of the excluded middle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
40. There are two ways to write error-free programs; only the third one works.
105. You can't communicate complexity, only an awareness of it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
90. Computation has made the tree flower.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
61. In programming, as in everything else, to be in error is to be reborn.
3. Syntactic sugar causes cancer of the semicolon.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
59. In English every word can be verbed. Would that it were so in our programming languages.
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
60. In seeking the unattainable, simplicity only gets in the way.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
61. In programming, as in everything else, to be in error is to be reborn.
40. There are two ways to write error-free programs; only the third one works.
102. One can't proceed from the informal to the formal by formal means.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
27. Once you understand how to write a program get someone else to write it.
100. We will never run out of things to program as long as there is a single program around.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
105. You can't communicate complexity, only an awareness of it.
12. Recursion is the root of computation since it trades description for time.
90. Computation has made the tree flower.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
15. Everything should be built top-down, except the first time.
46. Like punning, programming is a play on words.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
57. It is easier to change the specification to fit the program than vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
55. A LISP programmer knows the value of everything, but the cost of nothing.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
66. Making something variable is easy. Controlling duration of constancy is the trick.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
22. A good system can't have a weak command language.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
12. Recursion is the root of computation since it trades description for time.
59. In English every word can be verbed. Would that it were so in our programming languages.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
79. A year spent in artificial intelligence is enough to make one believe in God.
23. To understand a program you must become both the machine and the program.
22. A good system can't have a weak command language.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
96. Computers don't introduce order anywhere as much as they expose opportunities.
31. Simplicity does not precede complexity, but follows it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
100. We will never run out of things to program as long as there is a single program around.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
105. You can't communicate complexity, only an awareness of it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
57. It is easier to change the specification to fit the program than vice versa.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
105. You can't communicate complexity, only an awareness of it.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
104. The proof of a system's value is its existence.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
55. A LISP programmer knows the value of everything, but the cost of nothing.
95. Don't have good ideas if you aren't willing to be responsible for them.
41. Some programming languages manage to absorb change, but withstand progress.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
8. A programming language is low level when its programs require attention to the irrelevant.
57. It is easier to change the specification to fit the program than vice versa.
38. Structured Programming supports the law of the excluded middle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
108. Whenever two programmers meet to criticize their programs, both are silent.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
40. There are two ways to write error-free programs; only the third one works.
119. Programming is an unnatural act.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
115. Most people find the concept of programming obvious, but the doing impossible.
96. Computers don't introduce order anywhere as much as they expose opportunities.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
114. Within a computer natural language is unnatural.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
4. Every program is a part of some other program and rarely fits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
63. When we write programs that "learn", it turns out that we do and they don't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
119. Programming is an unnatural act.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
72. An adequate bootstrap is a contradiction in terms.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
40. There are two ways to write error-free programs; only the third one works.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
119. Programming is an unnatural act.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
22. A good system can't have a weak command language.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
115. Most people find the concept of programming obvious, but the doing impossible.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
22. A good system can't have a weak command language.
23. To understand a program you must become both the machine and the program.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
31. Simplicity does not precede complexity, but follows it.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
17. If a listener nods his head when you're explaining your program, wake him up.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
14. In the long run every program becomes rococo - then rubble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
98. In computing, the mean time to failure keeps getting shorter.
60. In seeking the unattainable, simplicity only gets in the way.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
21. Optimization hinders evolution.
63. When we write programs that "learn", it turns out that we do and they don't.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
60. In seeking the unattainable, simplicity only gets in the way.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
46. Like punning, programming is a play on words.
41. Some programming languages manage to absorb change, but withstand progress.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
22. A good system can't have a weak command language.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
78. If your computer speaks English, it was probably made in Japan.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
72. An adequate bootstrap is a contradiction in terms.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
1. One man's constant is another man's variable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
27. Once you understand how to write a program get someone else to write it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
8. A programming language is low level when its programs require attention to the irrelevant.
55. A LISP programmer knows the value of everything, but the cost of nothing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
40. There are two ways to write error-free programs; only the third one works.
105. You can't communicate complexity, only an awareness of it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
11. If you have a procedure with ten parameters, you probably missed some.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
21. Optimization hinders evolution.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
7. It is easier to write an incorrect program than understand a correct one.
111. Why did the Roman Empire collapse? What is Latin for office automation?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
15. Everything should be built top-down, except the first time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
102. One can't proceed from the informal to the formal by formal means.
57. It is easier to change the specification to fit the program than vice versa.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
12. Recursion is the root of computation since it trades description for time.
15. Everything should be built top-down, except the first time.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
79. A year spent in artificial intelligence is enough to make one believe in God.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
63. When we write programs that "learn", it turns out that we do and they don't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
108. Whenever two programmers meet to criticize their programs, both are silent.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
111. Why did the Roman Empire collapse? What is Latin for office automation?
41. Some programming languages manage to absorb change, but withstand progress.
96. Computers don't introduce order anywhere as much as they expose opportunities.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
72. An adequate bootstrap is a contradiction in terms.
119. Programming is an unnatural act.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
12. Recursion is the root of computation since it trades description for time.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
22. A good system can't have a weak command language.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
90. Computation has made the tree flower.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
63. When we write programs that "learn", it turns out that we do and they don't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
72. An adequate bootstrap is a contradiction in terms.
100. We will never run out of things to program as long as there is a single program around.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
66. Making something variable is easy. Controlling duration of constancy is the trick.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
72. An adequate bootstrap is a contradiction in terms.
22. A good system can't have a weak command language.
27. Once you understand how to write a program get someone else to write it.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
108. Whenever two programmers meet to criticize their programs, both are silent.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
.
24,92p
964,1008d
1015,1018p
622,923c
40. There are two ways to write error-free programs; only the third one works.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
62. In computing, invariants are ephemeral.
61. In programming, as in everything else, to be in error is to be reborn.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
72. An adequate bootstrap is a contradiction in terms.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
102. One can't proceed from the informal to the formal by formal means.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
11. If you have a procedure with ten parameters, you probably missed some.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
4. Every program is a part of some other program and rarely fits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
79. A year spent in artificial intelligence is enough to make one believe in God.
43. In software systems, it is often the early bird that makes the worm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
22. A good system can't have a weak command language.
57. It is easier to change the specification to fit the program than vice versa.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
14. In the long run every program becomes rococo - then rubble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
31. Simplicity does not precede complexity, but follows it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
15. Everything should be built top-down, except the first time.
22. A good system can't have a weak command language.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
3. Syntactic sugar causes cancer of the semicolon.
38. Structured Programming supports the law of the excluded middle.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
114. Within a computer natural language is unnatural.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
111. Why did the Roman Empire collapse? What is Latin for office automation?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
98. In computing, the mean time to failure keeps getting shorter.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
3. Syntactic sugar causes cancer of the semicolon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
72. An adequate bootstrap is a contradiction in terms.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
102. One can't proceed from the informal to the formal by formal means.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
100. We will never run out of things to program as long as there is a single program around.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
59. In English every word can be verbed. Would that it were so in our programming languages.
61. In programming, as in everything else, to be in error is to be reborn.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
78. If your computer speaks English, it was probably made in Japan.
114. Within a computer natural language is unnatural.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
23. To understand a program you must become both the machine and the program.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
40. There are two ways to write error-free programs; only the third one works.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
7. It is easier to write an incorrect program than understand a correct one.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
27. Once you understand how to write a program get someone else to write it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
43. In software systems, it is often the early bird that makes the worm.
108. Whenever two programmers meet to criticize their programs, both are silent.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
43. In software systems, it is often the early bird that makes the worm.
79. A year spent in artificial intelligence is enough to make one believe in God.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
31. Simplicity does not precede complexity, but follows it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
105. You can't communicate complexity, only an awareness of it.
102. One can't proceed from the informal to the formal by formal means.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
18. A program without a loop and a structured variable isn't worth writing.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
62. In computing, invariants are ephemeral.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
102. One can't proceed from the informal to the formal by formal means.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
41. Some programming languages manage to absorb change, but withstand progress.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
8. A programming language is low level when its programs require attention to the irrelevant.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
78. If your computer speaks English, it was probably made in Japan.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
72. An adequate bootstrap is a contradiction in terms.
47. As Will Rogers would have said, "There is no such thing as a free variable."
104. The proof of a system's value is its existence.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
43. In software systems, it is often the early bird that makes the worm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
19. A language that doesn't affect the way you think about programming, is not worth knowing.
100. We will never run out of things to program as long as there is a single program around.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
72. An adequate bootstrap is a contradiction in terms.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
12. Recursion is the root of computation since it trades description for time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
1. One man's constant is another man's variable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
59. In English every word can be verbed. Would that it were so in our programming languages.
103. Purely applicative languages are poorly applicable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
22. A good system can't have a weak command language.
76. It is the user who should parameterize procedures, not their creators.
47. As Will Rogers would have said, "There is no such thing as a free variable."
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
1. One man's constant is another man's variable.
43. In software systems, it is often the early bird that makes the worm.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
.
217u
395u
27,236p
612r
548r
820,949d
618,925p
496,519c
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
8. A programming language is low level when its programs require attention to the irrelevant.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
17. If a listener nods his head when you're explaining your program, wake him up.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
119. Programming is an unnatural act.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
.
319,682c
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
11. If you have a procedure with ten parameters, you probably missed some.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
119. Programming is an unnatural act.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
105. You can't communicate complexity, only an awareness of it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
41. Some programming languages manage to absorb change, but withstand progress.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
55. A LISP programmer knows the value of everything, but the cost of nothing.
95. Don't have good ideas if you aren't willing to be responsible for them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
78. If your computer speaks English, it was probably made in Japan.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
15. Everything should be built top-down, except the first time.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
46. Like punning, programming is a play on words.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
100. We will never run out of things to program as long as there is a single program around.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
95. Don't have good ideas if you aren't willing to be responsible for them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
57. It is easier to change the specification to fit the program than vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
105. You can't communicate complexity, only an awareness of it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
46. Like punning, programming is a play on words.
98. In computing, the mean time to failure keeps getting shorter.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
62. In computing, invariants are ephemeral.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
115. Most people find the concept of programming obvious, but the doing impossible.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
38. Structured Programming supports the law of the excluded middle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
23. To understand a program you must become both the machine and the program.
23. To understand a program you must become both the machine and the program.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
60. In seeking the unattainable, simplicity only gets in the way.
105. You can't communicate complexity, only an awareness of it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
105. You can't communicate complexity, only an awareness of it.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
108. Whenever two programmers meet to criticize their programs, both are silent.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
17. If a listener nods his head when you're explaining your program, wake him up.
14. In the long run every program becomes rococo - then rubble.
1. One man's constant is another man's variable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
76. It is the user who should parameterize procedures, not their creators.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
3. Syntactic sugar causes cancer of the semicolon.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
14. In the long run every program becomes rococo - then rubble.
22. A good system can't have a weak command language.
14. In the long run every program becomes rococo - then rubble.
57. It is easier to change the specification to fit the program than vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
43. In software systems, it is often the early bird that makes the worm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
62. In computing, invariants are ephemeral.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
96. Computers don't introduce order anywhere as much as they expose opportunities.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
98. In computing, the mean time to failure keeps getting shorter.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
1. One man's constant is another man's variable.
46. Like punning, programming is a play on words.
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
62. In computing, invariants are ephemeral.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
79. A year spent in artificial intelligence is enough to make one believe in God.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
11. If you have a procedure with ten parameters, you probably missed some.
100. We will never run out of things to program as long as there is a single program around.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
60. In seeking the unattainable, simplicity only gets in the way.
114. Within a computer natural language is unnatural.
21. Optimization hinders evolution.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
4. Every program is a part of some other program and rarely fits.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
21. Optimization hinders evolution.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
98. In computing, the mean time to failure keeps getting shorter.
98. In computing, the mean time to failure keeps getting shorter.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
111. Why did the Roman Empire collapse? What is Latin for office automation?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
103. Purely applicative languages are poorly applicable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
23. To understand a program you must become both the machine and the program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
22. A good system can't have a weak command language.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
8. A programming language is low level when its programs require attention to the irrelevant.
102. One can't proceed from the informal to the formal by formal means.
7. It is easier to write an incorrect program than understand a correct one.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
1. One man's constant is another man's variable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
17. If a listener nods his head when you're explaining your program, wake him up.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
76. It is the user who should parameterize procedures, not their creators.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
55. A LISP programmer knows the value of everything, but the cost of nothing.
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
66. Making something variable is easy. Controlling duration of constancy is the trick.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
12. Recursion is the root of computation since it trades description for time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
8. A programming language is low level when its programs require attention to the irrelevant.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
18. A program without a loop and a structured variable isn't worth writing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
7. It is easier to write an incorrect program than understand a correct one.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
90. Computation has made the tree flower.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
4. Every program is a part of some other program and rarely fits.
90. Computation has made the tree flower.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
96. Computers don't introduce order anywhere as much as they expose opportunities.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
31. Simplicity does not precede complexity, but follows it.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
98. In computing, the mean time to failure keeps getting shorter.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
4. Every program is a part of some other program and rarely fits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
108. Whenever two programmers meet to criticize their programs, both are silent.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
104. The proof of a system's value is its existence.
111. Why did the Roman Empire collapse? What is Latin for office automation?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
115. Most people find the concept of programming obvious, but the doing impossible.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
3. Syntactic sugar causes cancer of the semicolon.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
43. In software systems, it is often the early bird that makes the worm.
62. In computing, invariants are ephemeral.
63. When we write programs that "learn", it turns out that we do and they don't.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
78. If your computer speaks English, it was probably made in Japan.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
23. To understand a program you must become both the machine and the program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
112. Computer Science is embarrassed by the computer.
.
631,845p
392r
1000,1015p
291u
647,1022d
1,914c
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
57. It is easier to change the specification to fit the program than vice versa.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
12. Recursion is the root of computation since it trades description for time.
31. Simplicity does not precede complexity, but follows it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
103. Purely applicative languages are poorly applicable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
62. In computing, invariants are ephemeral.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
8. A programming language is low level when its programs require attention to the irrelevant.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
7. It is easier to write an incorrect program than understand a correct one.
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
95. Don't have good ideas if you aren't willing to be responsible for them.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
40. There are two ways to write error-free programs; only the third one works.
4. Every program is a part of some other program and rarely fits.
55. A LISP programmer knows the value of everything, but the cost of nothing.
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
72. An adequate bootstrap is a contradiction in terms.
66. Making something variable is easy. Controlling duration of constancy is the trick.
1. One man's constant is another man's variable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
59. In English every word can be verbed. Would that it were so in our programming languages.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
1. One man's constant is another man's variable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
22. A good system can't have a weak command language.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
14. In the long run every program becomes rococo - then rubble.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
8. A programming language is low level when its programs require attention to the irrelevant.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
100. We will never run out of things to program as long as there is a single program around.
104. The proof of a system's value is its existence.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
14. In the long run every program becomes rococo - then rubble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
63. When we write programs that "learn", it turns out that we do and they don't.
57. It is easier to change the specification to fit the program than vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
23. To understand a program you must become both the machine and the program.
72. An adequate bootstrap is a contradiction in terms.
46. Like punning, programming is a play on words.
38. Structured Programming supports the law of the excluded middle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
11. If you have a procedure with ten parameters, you probably missed some.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
40. There are two ways to write error-free programs; only the third one works.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
105. You can't communicate complexity, only an awareness of it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
22. A good system can't have a weak command language.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
96. Computers don't introduce order anywhere as much as they expose opportunities.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
115. Most people find the concept of programming obvious, but the doing impossible.
23. To understand a program you must become both the machine and the program.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
119. Programming is an unnatural act.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
119. Programming is an unnatural act.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
23. To understand a program you must become both the machine and the program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
100. We will never run out of things to program as long as there is a single program around.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
15. Everything should be built top-down, except the first time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
17. If a listener nods his head when you're explaining your program, wake him up.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
15. Everything should be built top-down, except the first time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
62. In computing, invariants are ephemeral.
76. It is the user who should parameterize procedures, not their creators.
103. Purely applicative languages are poorly applicable.
111. Why did the Roman Empire collapse? What is Latin for office automation?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
112. Computer Science is embarrassed by the computer.
17. If a listener nods his head when you're explaining your program, wake him up.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
63. When we write programs that "learn", it turns out that we do and they don't.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
102. One can't proceed from the informal to the formal by formal means.
114. Within a computer natural language is unnatural.
98. In computing, the mean time to failure keeps getting shorter.
61. In programming, as in everything else, to be in error is to be reborn.
38. Structured Programming supports the law of the excluded middle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
3. Syntactic sugar causes cancer of the semicolon.
57. It is easier to change the specification to fit the program than vice versa.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
41. Some programming languages manage to absorb change, but withstand progress.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
57. It is easier to change the specification to fit the program than vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
23. To understand a program you must become both the machine and the program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
108. Whenever two programmers meet to criticize their programs, both are silent.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
23. To understand a program you must become both the machine and the program.
114. Within a computer natural language is unnatural.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
78. If your computer speaks English, it was probably made in Japan.
78. If your computer speaks English, it was probably made in Japan.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
104. The proof of a system's value is its existence.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
60. In seeking the unattainable, simplicity only gets in the way.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
38. Structured Programming supports the law of the excluded middle.
78. If your computer speaks English, it was probably made in Japan.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
46. Like punning, programming is a play on words.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
119. Programming is an unnatural act.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
57. It is easier to change the specification to fit the program than vice versa.
23. To understand a program you must become both the machine and the program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
78. If your computer speaks English, it was probably made in Japan.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
57. It is easier to change the specification to fit the program than vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
17. If a listener nods his head when you're explaining your program, wake him up.
23. To understand a program you must become both the machine and the program.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
55. A LISP programmer knows the value of everything, but the cost of nothing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
1. One man's constant is another man's variable.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
43. In software systems, it is often the early bird that makes the worm.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
21. Optimization hinders evolution.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
31. Simplicity does not precede complexity, but follows it.
38. Structured Programming supports the law of the excluded middle.
61. In programming, as in everything else, to be in error is to be reborn.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
102. One can't proceed from the informal to the formal by formal means.
90. Computation has made the tree flower.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
61. In programming, as in everything else, to be in error is to be reborn.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
60. In seeking the unattainable, simplicity only gets in the way.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
72. An adequate bootstrap is a contradiction in terms.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
103. Purely applicative languages are poorly applicable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
18. A program without a loop and a structured variable isn't worth writing.
38. Structured Programming supports the law of the excluded middle.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
60. In seeking the unattainable, simplicity only gets in the way.
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
38. Structured Programming supports the law of the excluded middle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
15. Everything should be built top-down, except the first time.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
4. Every program is a part of some other program and rarely fits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
47. As Will Rogers would have said, "There is no such thing as a free variable."
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
27. Once you understand how to write a program get someone else to write it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
95. Don't have good ideas if you aren't willing to be responsible for them.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
79. A year spent in artificial intelligence is enough to make one believe in God.
17. If a listener nods his head when you're explaining your program, wake him up.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
41. Some programming languages manage to absorb change, but withstand progress.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
41. Some programming languages manage to absorb change, but withstand progress.
27. Once you understand how to write a program get someone else to write it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
72. An adequate bootstrap is a contradiction in terms.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
79. A year spent in artificial intelligence is enough to make one believe in God.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
41. Some programming languages manage to absorb change, but withstand progress.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
103. Purely applicative languages are poorly applicable.
8. A programming language is low level when its programs require attention to the irrelevant.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
79. A year spent in artificial intelligence is enough to make one believe in God.
98. In computing, the mean time to failure keeps getting shorter.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
17. If a listener nods his head when you're explaining your program, wake him up.
57. It is easier to change the specification to fit the program than vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
76. It is the user who should parameterize procedures, not their creators.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
96. Computers don't introduce order anywhere as much as they expose opportunities.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
27. Once you understand how to write a program get someone else to write it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
114. Within a computer natural language is unnatural.
76. It is the user who should parameterize procedures, not their creators.
108. Whenever two programmers meet to criticize their programs, both are silent.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
102. One can't proceed from the informal to the formal by formal means.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
60. In seeking the unattainable, simplicity only gets in the way.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
105. You can't communicate complexity, only an awareness of it.
72. An adequate bootstrap is a contradiction in terms.
57. It is easier to change the specification to fit the program than vice versa.
66. Making something variable is easy. Controlling duration of constancy is the trick.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
103. Purely applicative languages are poorly applicable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
15. Everything should be built top-down, except the first time.
57. It is easier to change the specification to fit the program than vice versa.
102. One can't proceed from the informal to the formal by formal means.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
95. Don't have good ideas if you aren't willing to be responsible for them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
100. We will never run out of things to program as long as there is a single program around.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
90. Computation has made the tree flower.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
110. Editing is a rewording activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
108. Whenever two programmers meet to criticize their programs, both are silent.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
114. Within a computer natural language is unnatural.
15. Everything should be built top-down, except the first time.
98. In computing, the mean time to failure keeps getting shorter.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
3. Syntactic sugar causes cancer of the semicolon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
90. Computation has made the tree flower.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
102. One can't proceed from the informal to the formal by formal means.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
15. Everything should be built top-down, except the first time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
63. When we write programs that "learn", it turns out that we do and they don't.
104. The proof of a system's value is its existence.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
98. In computing, the mean time to failure keeps getting shorter.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
112. Computer Science is embarrassed by the computer.
60. In seeking the unattainable, simplicity only gets in the way.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
60. In seeking the unattainable, simplicity only gets in the way.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
78. If your computer speaks English, it was probably made in Japan.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
15. Everything should be built top-down, except the first time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
17. If a listener nods his head when you're explaining your program, wake him up.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
23. To understand a program you must become both the machine and the program.
60. In seeking the unattainable, simplicity only gets in the way.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
95. Don't have good ideas if you aren't willing to be responsible for them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
119. Programming is an unnatural act.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
62. In computing, invariants are ephemeral.
17. If a listener nods his head when you're explaining your program, wake him up.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
14. In the long run every program becomes rococo - then rubble.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
90. Computation has made the tree flower.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
98. In computing, the mean time to failure keeps getting shorter.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
110. Editing is a rewording activity.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
8. A programming language is low level when its programs require attention to the irrelevant.
108. Whenever two programmers meet to criticize their programs, both are silent.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
46. Like punning, programming is a play on words.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
1. One man's constant is another man's variable.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
14. In the long run every program becomes rococo - then rubble.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
102. One can't proceed from the informal to the formal by formal means.
79. A year spent in artificial intelligence is enough to make one believe in God.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
115. Most people find the concept of programming obvious, but the doing impossible.
66. Making something variable is easy. Controlling duration of constancy is the trick.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
59. In English every word can be verbed. Would that it were so in our programming languages.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
108. Whenever two programmers meet to criticize their programs, both are silent.
66. Making something variable is easy. Controlling duration of constancy is the trick.
90. Computation has made the tree flower.
114. Within a computer natural language is unnatural.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
66. Making something variable is easy. Controlling duration of constancy is the trick.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
47. As Will Rogers would have said, "There is no such thing as a free variable."
31. Simplicity does not precede complexity, but follows it.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
78. If your computer speaks English, it was probably made in Japan.
102. One can't proceed from the informal to the formal by formal means.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
60. In seeking the unattainable, simplicity only gets in the way.
21. Optimization hinders evolution.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
59. In English every word can be verbed. Would that it were so in our programming languages.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
108. Whenever two programmers meet to criticize their programs, both are silent.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
22. A good system can't have a weak command language.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
62. In computing, invariants are ephemeral.
55. A LISP programmer knows the value of everything, but the cost of nothing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
102. One can't proceed from the informal to the formal by formal means.
12. Recursion is the root of computation since it trades description for time.
40. There are two ways to write error-free programs; only the third one works.
12. Recursion is the root of computation since it trades description for time.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
21. Optimization hinders evolution.
114. Within a computer natural language is unnatural.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
43. In software systems, it is often the early bird that makes the worm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
102. One can't proceed from the informal to the formal by formal means.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
72. An adequate bootstrap is a contradiction in terms.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
17. If a listener nods his head when you're explaining your program, wake him up.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
79. A year spent in artificial intelligence is enough to make one believe in God.
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
114. Within a computer natural language is unnatural.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
22. A good system can't have a weak command language.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
8. A programming language is low level when its programs require attention to the irrelevant.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
14. In the long run every program becomes rococo - then rubble.
22. A good system can't have a weak command language.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
17. If a listener nods his head when you're explaining your program, wake him up.
119. Programming is an unnatural act.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
100. We will never run out of things to program as long as there is a single program around.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
18. A program without a loop and a structured variable isn't worth writing.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
15. Everything should be built top-down, except the first time.
95. Don't have good ideas if you aren't willing to be responsible for them.
7. It is easier to write an incorrect program than understand a correct one.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
105. You can't communicate complexity, only an awareness of it.
11. If you have a procedure with ten parameters, you probably missed some.
102. One can't proceed from the informal to the formal by formal means.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
22. A good system can't have a weak command language.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
38. Structured Programming supports the law of the excluded middle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
59. In English every word can be verbed. Would that it were so in our programming languages.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
102. One can't proceed from the informal to the formal by formal means.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
41. Some programming languages manage to absorb change, but withstand progress.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
60. In seeking the unattainable, simplicity only gets in the way.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
38. Structured Programming supports the law of the excluded middle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
21. Optimization hinders evolution.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
103. Purely applicative languages are poorly applicable.
21. Optimization hinders evolution.
15. Everything should be built top-down, except the first time.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
14. In the long run every program becomes rococo - then rubble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
11. If you have a procedure with ten parameters, you probably missed some.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
72. An adequate bootstrap is a contradiction in terms.
.
197,514p
469,693p
286u
157,317p
35r
727,859c
112. Computer Science is embarrassed by the computer.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
3. Syntactic sugar causes cancer of the semicolon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
78. If your computer speaks English, it was probably made in Japan.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
55. A LISP programmer knows the value of everything, but the cost of nothing.
14. In the long run every program becomes rococo - then rubble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
8. A programming language is low level when its programs require attention to the irrelevant.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
21. Optimization hinders evolution.
102. One can't proceed from the informal to the formal by formal means.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
108. Whenever two programmers meet to criticize their programs, both are silent.
41. Some programming languages manage to absorb change, but withstand progress.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
66. Making something variable is easy. Controlling duration of constancy is the trick.
21. Optimization hinders evolution.
96. Computers don't introduce order anywhere as much as they expose opportunities.
79. A year spent in artificial intelligence is enough to make one believe in God.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
38. Structured Programming supports the law of the excluded middle.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
41. Some programming languages manage to absorb change, but withstand progress.
76. It is the user who should parameterize procedures, not their creators.
110. Editing is a rewording activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
115. Most people find the concept of programming obvious, but the doing impossible.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
40. There are two ways to write error-free programs; only the third one works.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
72. An adequate bootstrap is a contradiction in terms.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
114. Within a computer natural language is unnatural.
14. In the long run every program becomes rococo - then rubble.
104. The proof of a system's value is its existence.
3. Syntactic sugar causes cancer of the semicolon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
115. Most people find the concept of programming obvious, but the doing impossible.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
104. The proof of a system's value is its existence.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
76. It is the user who should parameterize procedures, not their creators.
66. Making something variable is easy. Controlling duration of constancy is the trick.
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
119. Programming is an unnatural act.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
12. Recursion is the root of computation since it trades description for time.
115. Most people find the concept of programming obvious, but the doing impossible.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
47. As Will Rogers would have said, "There is no such thing as a free variable."
108. Whenever two programmers meet to criticize their programs, both are silent.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
66. Making something variable is easy. Controlling duration of constancy is the trick.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
100. We will never run out of things to program as long as there is a single program around.
104. The proof of a system's value is its existence.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
22. A good system can't have a weak command language.
114. Within a computer natural language is unnatural.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
105. You can't communicate complexity, only an awareness of it.
60. In seeking the unattainable, simplicity only gets in the way.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
.
726u
35,210p
239,575p
q
